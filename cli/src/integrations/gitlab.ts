/**
 * GitLab MR Integration Module
 * 
 * Posts regression analysis results as MR (Merge Request) notes with rich formatting.
 * Supports commit discussions and trend comparison.
 */

import axios from 'axios';
import { RegressionResult } from '../core/regression';
import { BatchResult } from '../core/batch';

export interface GitLabConfig {
  /** GitLab API token */
  token: string;
  /** Project ID or path (e.g., 'group/project') */
  projectId: string;
  /** Merge request IID (internal ID) */
  mrIid: number;
  /** Optional: GitLab instance URL (default: gitlab.com) */
  baseUrl?: string;
}

export interface MRNoteOptions {
  /** Include detailed metrics table */
  includeDetails?: boolean;
  /** Include historical trend comparison */
  includeTrends?: boolean;
  /** Dashboard URL for "View Details" link */
  dashboardUrl?: string;
  /** Commit SHA for discussions */
  commitSha?: string;
}

/**
 * Format regression result as markdown for MR note
 */
export function formatRegressionForMR(
  result: RegressionResult,
  options: MRNoteOptions = {}
): string {
  const { includeDetails = true } = options;
  
  const icon = result.verdict === 'FAIL' ? ':x:' : result.verdict === 'WARN' ? ':warning:' : ':white_check_mark:';
  const verdict = result.verdict === 'FAIL' ? 'Regression Detected' : 
                  result.verdict === 'WARN' ? 'Warning' : 'No Regression';
  
  let note = `## ${icon} VITALS ${verdict}\n\n`;
  
  // Summary
  const changeSign = result.change_percent > 0 ? '+' : '';
  note += `**${result.metric}**: ${changeSign}${result.change_percent.toFixed(1)}%\n`;
  note += `- Statistical Significance: p=${result.p_value.toFixed(3)} ${result.p_value < 0.05 ? '(significant)' : '(not significant)'}\n`;
  note += `- Effect Size: ${result.effect_size.toFixed(2)} ${result.effect_size > 0.5 ? '(large)' : '(small)'}\n\n`;
  
  if (includeDetails) {
    note += '### Details\n\n';
    note += '| Metric | Baseline | Candidate | Change |\n';
    note += '|--------|----------|-----------|--------|\n';
    note += `| ${result.metric} | ${result.baseline.mean.toFixed(2)} | ${result.candidate.mean.toFixed(2)} | ${changeSign}${result.change_percent.toFixed(1)}% |\n\n`;
    
    note += `**Baseline Samples**: ${result.baseline.samples}\n`;
    note += `**Candidate Samples**: ${result.candidate.samples}\n\n`;
  }
  
  // Suggested action
  if (result.verdict === 'FAIL') {
    note += '### Suggested Action\n\n';
    note += ':arrows_counterclockwise: **Consider rolling back** this deployment using canary strategy.\n\n';
  } else if (result.verdict === 'WARN') {
    note += '### Suggested Action\n\n';
    note += ':eyes: **Monitor closely** - Change detected but not statistically significant.\n\n';
  }
  
  if (options.dashboardUrl) {
    note += `[:chart_with_upwards_trend: View Detailed Dashboard](${options.dashboardUrl})\n\n`;
  }
  
  note += '---\n';
  note += '_Generated by [VITALS](https://github.com/theaniketraj/vitals) - Performance Regression Detection_';
  
  return note;
}

/**
 * Format batch results as markdown for MR note
 */
export function formatBatchResultsForMR(
  batchResult: BatchResult,
  options: MRNoteOptions = {}
): string {
  const { includeDetails = true } = options;
  
  const overallFailed = batchResult.summary.failed > 0;
  const overallWarned = batchResult.summary.warned > 0 && batchResult.summary.failed === 0;
  
  const icon = overallFailed ? ':x:' : overallWarned ? ':warning:' : ':white_check_mark:';
  const verdict = overallFailed ? 'Regressions Detected' : 
                  overallWarned ? 'Warnings Detected' : 'No Regressions';
  
  let note = `## ${icon} VITALS ${verdict}\n\n`;
  
  // Summary
  note += '### Summary\n\n';
  note += `- :white_check_mark: **Passed**: ${batchResult.summary.passed}\n`;
  note += `- :x: **Failed**: ${batchResult.summary.failed}\n`;
  note += `- :warning: **Warned**: ${batchResult.summary.warned}\n`;
  note += `- :warning: **Errored**: ${batchResult.summary.errored}\n`;
  note += `- :stopwatch: **Duration**: ${(batchResult.executionTime / 1000).toFixed(2)}s\n\n`;
  
  if (includeDetails) {
    // Failed metrics (highest priority)
    const failedMetrics: [string, RegressionResult][] = [];
    const warnedMetrics: [string, RegressionResult][] = [];
    const passedMetrics: [string, RegressionResult][] = [];
    
    for (const [metric, result] of batchResult.results) {
      if (result instanceof Error) continue;
      
      if (result.verdict === 'FAIL') {
        failedMetrics.push([metric, result]);
      } else if (result.verdict === 'WARN') {
        warnedMetrics.push([metric, result]);
      } else if (result.verdict === 'PASS') {
        passedMetrics.push([metric, result]);
      }
    }
    
    if (failedMetrics.length > 0) {
      note += '### :x: Failed Metrics\n\n';
      note += '| Metric | Change | p-value | Effect Size | Verdict |\n';
      note += '|--------|--------|---------|-------------|----------|\n';
      
      for (const [metric, result] of failedMetrics) {
        const changeSign = result.change_percent > 0 ? '+' : '';
        note += `| ${metric} | ${changeSign}${result.change_percent.toFixed(1)}% | ${result.p_value.toFixed(3)} | ${result.effect_size.toFixed(2)} | FAIL |\n`;
      }
      note += '\n';
    }
    
    if (warnedMetrics.length > 0) {
      note += '### :warning: Warned Metrics\n\n';
      note += '| Metric | Change | p-value | Effect Size | Verdict |\n';
      note += '|--------|--------|---------|-------------|----------|\n';
      
      for (const [metric, result] of warnedMetrics) {
        const changeSign = result.change_percent > 0 ? '+' : '';
        note += `| ${metric} | ${changeSign}${result.change_percent.toFixed(1)}% | ${result.p_value.toFixed(3)} | ${result.effect_size.toFixed(2)} | WARN |\n`;
      }
      note += '\n';
    }
    
    if (passedMetrics.length > 0) {
      note += '<details>\n<summary>:white_check_mark: Passed Metrics</summary>\n\n';
      note += '| Metric | Change | p-value | Effect Size |\n';
      note += '|--------|--------|---------|-------------|\n';
      
      for (const [metric, result] of passedMetrics) {
        const changeSign = result.change_percent > 0 ? '+' : '';
        note += `| ${metric} | ${changeSign}${result.change_percent.toFixed(1)}% | ${result.p_value.toFixed(3)} | ${result.effect_size.toFixed(2)} |\n`;
      }
      note += '\n</details>\n\n';
    }
  }
  
  // Suggested action
  if (overallFailed) {
    note += '### :arrows_counterclockwise: Suggested Action\n\n';
    note += '**Consider rolling back** this deployment. Multiple metrics show significant regression.\n\n';
  } else if (overallWarned) {
    note += '### :eyes: Suggested Action\n\n';
    note += '**Monitor closely** - Some metrics show changes that warrant attention.\n\n';
  }
  
  if (options.dashboardUrl) {
    note += `[:chart_with_upwards_trend: View Detailed Dashboard](${options.dashboardUrl})\n\n`;
  }
  
  note += '---\n';
  note += '_Generated by [VITALS](https://github.com/vitals-dev/vitals) - Performance Regression Detection_';
  
  return note;
}

/**
 * Post note to GitLab MR
 */
export async function postGitLabMRNote(
  config: GitLabConfig,
  note: string
): Promise<void> {
  const baseUrl = config.baseUrl || 'https://gitlab.com';
  const projectId = encodeURIComponent(config.projectId);
  const url = `${baseUrl}/api/v4/projects/${projectId}/merge_requests/${config.mrIid}/notes`;

  try {
    await axios.post(
      url,
      { body: note },
      {
        headers: {
          'PRIVATE-TOKEN': config.token,
          'Content-Type': 'application/json'
        }
      }
    );
  } catch (error) {
    throw new Error(`Failed to post GitLab MR note: ${error}`);
  }
}

/**
 * Update existing note if found, otherwise create new one
 */
export async function upsertGitLabMRNote(
  config: GitLabConfig,
  note: string,
  marker = '<!-- vitals-regression-note -->'
): Promise<void> {
  const baseUrl = config.baseUrl || 'https://gitlab.com';
  const projectId = encodeURIComponent(config.projectId);
  const notesUrl = `${baseUrl}/api/v4/projects/${projectId}/merge_requests/${config.mrIid}/notes`;

  try {
    // Fetch existing notes
    const { data: notes } = await axios.get(notesUrl, {
      headers: {
        'PRIVATE-TOKEN': config.token
      }
    });

    const markedNote = `${marker}\n${note}`;
    const existingNote = notes.find((n: any) => n.body?.includes(marker));

    if (existingNote) {
      // Update existing note
      await axios.put(
        `${notesUrl}/${existingNote.id}`,
        { body: markedNote },
        {
          headers: {
            'PRIVATE-TOKEN': config.token,
            'Content-Type': 'application/json'
          }
        }
      );
    } else {
      // Create new note
      await axios.post(
        notesUrl,
        { body: markedNote },
        {
          headers: {
            'PRIVATE-TOKEN': config.token,
            'Content-Type': 'application/json'
          }
        }
      );
    }
  } catch (error) {
    throw new Error(`Failed to upsert GitLab MR note: ${error}`);
  }
}

/**
 * Create commit discussion
 */
export async function createGitLabCommitDiscussion(
  config: GitLabConfig & { commitSha: string },
  result: RegressionResult,
  message: string
): Promise<void> {
  const baseUrl = config.baseUrl || 'https://gitlab.com';
  const projectId = encodeURIComponent(config.projectId);
  const url = `${baseUrl}/api/v4/projects/${projectId}/repository/commits/${config.commitSha}/discussions`;

  try {
    await axios.post(
      url,
      { body: message },
      {
        headers: {
          'PRIVATE-TOKEN': config.token,
          'Content-Type': 'application/json'
        }
      }
    );
  } catch (error) {
    throw new Error(`Failed to create GitLab commit discussion: ${error}`);
  }
}

/**
 * Update MR status (e.g., set pipeline status)
 */
export async function updateGitLabMRStatus(
  config: GitLabConfig & { commitSha: string },
  status: 'success' | 'failed' | 'pending',
  description?: string
): Promise<void> {
  const baseUrl = config.baseUrl || 'https://gitlab.com';
  const projectId = encodeURIComponent(config.projectId);
  const url = `${baseUrl}/api/v4/projects/${projectId}/statuses/${config.commitSha}`;

  try {
    await axios.post(
      url,
      {
        state: status,
        name: 'VITALS Regression Check',
        description: description || 'Performance regression analysis',
        context: 'vitals/regression'
      },
      {
        headers: {
          'PRIVATE-TOKEN': config.token,
          'Content-Type': 'application/json'
        }
      }
    );
  } catch (error) {
    throw new Error(`Failed to update GitLab MR status: ${error}`);
  }
}

/**
 * Get GitLab config from environment variables
 */
export function getGitLabConfigFromEnv(): GitLabConfig | null {
  const token = process.env.GITLAB_TOKEN || process.env.CI_JOB_TOKEN;
  const projectId = process.env.CI_PROJECT_PATH || process.env.CI_PROJECT_ID;
  const mrIid = process.env.CI_MERGE_REQUEST_IID;

  if (!token || !projectId || !mrIid) {
    return null;
  }

  return {
    token,
    projectId,
    mrIid: parseInt(mrIid, 10),
    baseUrl: process.env.CI_SERVER_URL
  };
}
