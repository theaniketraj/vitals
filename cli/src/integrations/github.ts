/**
 * GitHub PR Integration Module
 * 
 * Posts regression analysis results as PR comments with rich formatting.
 * Supports commit annotations and trend comparison.
 */

import { Octokit } from '@octokit/rest';
import { RegressionResult } from '../core/regression';
import { BatchResult } from '../core/batch';

export interface GitHubConfig {
  /** GitHub API token */
  token: string;
  /** Repository owner */
  owner: string;
  /** Repository name */
  repo: string;
  /** Pull request number */
  prNumber: number;
  /** Optional: Base URL for custom GitHub Enterprise */
  baseUrl?: string;
}

export interface PRCommentOptions {
  /** Include detailed metrics table */
  includeDetails?: boolean;
  /** Include historical trend comparison */
  includeTrends?: boolean;
  /** Dashboard URL for "View Details" link */
  dashboardUrl?: string;
  /** Commit SHA for annotations */
  commitSha?: string;
}

/**
 * Format regression result as markdown for PR comment
 */
export function formatRegressionForPR(
  result: RegressionResult,
  options: PRCommentOptions = {}
): string {
  const { includeDetails = true } = options;
  
  const icon = result.verdict === 'FAIL' ? 'âŒ' : result.verdict === 'WARN' ? 'âš ï¸' : 'âœ…';
  const verdict = result.verdict === 'FAIL' ? 'Regression Detected' : 
                  result.verdict === 'WARN' ? 'Warning' : 'No Regression';
  
  let comment = `## ${icon} VITALS ${verdict}\n\n`;
  
  // Summary
  const changeSign = result.change_percent > 0 ? '+' : '';
  comment += `**${result.metric}**: ${changeSign}${result.change_percent.toFixed(1)}%\n`;
  comment += `- Statistical Significance: p=${result.p_value.toFixed(3)} ${result.p_value < 0.05 ? '(significant)' : '(not significant)'}\n`;
  comment += `- Effect Size: ${result.effect_size.toFixed(2)} ${result.effect_size > 0.5 ? '(large)' : '(small)'}\n\n`;
  
  if (includeDetails) {
    comment += '### Details\n\n';
    comment += '| Metric | Baseline | Candidate | Change |\n';
    comment += '|--------|----------|-----------|--------|\n';
    comment += `| ${result.metric} | ${result.baseline.mean.toFixed(2)} | ${result.candidate.mean.toFixed(2)} | ${changeSign}${result.change_percent.toFixed(1)}% |\n\n`;
    
    comment += `**Baseline Samples**: ${result.baseline.samples}\n`;
    comment += `**Candidate Samples**: ${result.candidate.samples}\n\n`;
  }
  
  // Suggested action
  if (result.verdict === 'FAIL') {
    comment += '### Suggested Action\n\n';
    comment += 'ðŸ”„ **Consider rolling back** this deployment using canary strategy.\n\n';
  } else if (result.verdict === 'WARN') {
    comment += '### Suggested Action\n\n';
    comment += 'ðŸ‘€ **Monitor closely** - Change detected but not statistically significant.\n\n';
  }
  
  if (options.dashboardUrl) {
    comment += `[ðŸ“Š View Detailed Dashboard](${options.dashboardUrl})\n\n`;
  }
  
  comment += '---\n';
  comment += '_Generated by [VITALS](https://github.com/vitals-dev/vitals) - Performance Regression Detection_';
  
  return comment;
}

/**
 * Format batch results as markdown for PR comment
 */
export function formatBatchResultsForPR(
  batchResult: BatchResult,
  options: PRCommentOptions = {}
): string {
  const { includeDetails = true } = options;
  
  const overallFailed = batchResult.summary.failed > 0;
  const overallWarned = batchResult.summary.warned > 0 && batchResult.summary.failed === 0;
  
  const icon = overallFailed ? 'âŒ' : overallWarned ? 'âš ï¸' : 'âœ…';
  const verdict = overallFailed ? 'Regressions Detected' : 
                  overallWarned ? 'Warnings Detected' : 'No Regressions';
  
  let comment = `## ${icon} VITALS ${verdict}\n\n`;
  
  // Summary
  comment += '### Summary\n\n';
  comment += `- âœ… **Passed**: ${batchResult.summary.passed}\n`;
  comment += `- âŒ **Failed**: ${batchResult.summary.failed}\n`;
  comment += `- âš ï¸ **Warned**: ${batchResult.summary.warned}\n`;
  comment += `- âš ï¸ **Errored**: ${batchResult.summary.errored}\n`;
  comment += `- â±ï¸ **Duration**: ${(batchResult.executionTime / 1000).toFixed(2)}s\n\n`;
  
  if (includeDetails) {
    // Failed metrics (highest priority)
    const failedMetrics: [string, RegressionResult][] = [];
    const warnedMetrics: [string, RegressionResult][] = [];
    const passedMetrics: [string, RegressionResult][] = [];
    
    for (const [metric, result] of batchResult.results) {
      if (result instanceof Error) continue;
      
      if (result.verdict === 'FAIL') {
        failedMetrics.push([metric, result]);
      } else if (result.verdict === 'WARN') {
        warnedMetrics.push([metric, result]);
      } else if (result.verdict === 'PASS') {
        passedMetrics.push([metric, result]);
      }
    }
    
    if (failedMetrics.length > 0) {
      comment += '### âŒ Failed Metrics\n\n';
      comment += '| Metric | Change | p-value | Effect Size | Verdict |\n';
      comment += '|--------|--------|---------|-------------|----------|\n';
      
      for (const [metric, result] of failedMetrics) {
        const changeSign = result.change_percent > 0 ? '+' : '';
        comment += `| ${metric} | ${changeSign}${result.change_percent.toFixed(1)}% | ${result.p_value.toFixed(3)} | ${result.effect_size.toFixed(2)} | FAIL |\n`;
      }
      comment += '\n';
    }
    
    if (warnedMetrics.length > 0) {
      comment += '### âš ï¸ Warned Metrics\n\n';
      comment += '| Metric | Change | p-value | Effect Size | Verdict |\n';
      comment += '|--------|--------|---------|-------------|----------|\n';
      
      for (const [metric, result] of warnedMetrics) {
        const changeSign = result.change_percent > 0 ? '+' : '';
        comment += `| ${metric} | ${changeSign}${result.change_percent.toFixed(1)}% | ${result.p_value.toFixed(3)} | ${result.effect_size.toFixed(2)} | WARN |\n`;
      }
      comment += '\n';
    }
    
    if (passedMetrics.length > 0) {
      comment += '<details>\n<summary>âœ… Passed Metrics</summary>\n\n';
      comment += '| Metric | Change | p-value | Effect Size |\n';
      comment += '|--------|--------|---------|-------------|\n';
      
      for (const [metric, result] of passedMetrics) {
        const changeSign = result.change_percent > 0 ? '+' : '';
        comment += `| ${metric} | ${changeSign}${result.change_percent.toFixed(1)}% | ${result.p_value.toFixed(3)} | ${result.effect_size.toFixed(2)} |\n`;
      }
      comment += '\n</details>\n\n';
    }
  }
  
  // Suggested action
  if (overallFailed) {
    comment += '### ðŸ”„ Suggested Action\n\n';
    comment += '**Consider rolling back** this deployment. Multiple metrics show significant regression.\n\n';
  } else if (overallWarned) {
    comment += '### ðŸ‘€ Suggested Action\n\n';
    comment += '**Monitor closely** - Some metrics show changes that warrant attention.\n\n';
  }
  
  if (options.dashboardUrl) {
    comment += `[ðŸ“Š View Detailed Dashboard](${options.dashboardUrl})\n\n`;
  }
  
  comment += '---\n';
  comment += '_Generated by [VITALS](https://github.com/vitals-dev/vitals) - Performance Regression Detection_';
  
  return comment;
}

/**
 * Post comment to GitHub PR
 */
export async function postGitHubPRComment(
  config: GitHubConfig,
  comment: string
): Promise<void> {
  const octokit = new Octokit({
    auth: config.token,
    baseUrl: config.baseUrl
  });

  try {
    await octokit.issues.createComment({
      owner: config.owner,
      repo: config.repo,
      issue_number: config.prNumber,
      body: comment
    });
  } catch (error) {
    throw new Error(`Failed to post GitHub PR comment: ${error}`);
  }
}

/**
 * Update existing comment if found, otherwise create new one
 */
export async function upsertGitHubPRComment(
  config: GitHubConfig,
  comment: string,
  marker = '<!-- vitals-regression-comment -->'
): Promise<void> {
  const octokit = new Octokit({
    auth: config.token,
    baseUrl: config.baseUrl
  });

  try {
    // Find existing VITALS comment
    const { data: comments } = await octokit.issues.listComments({
      owner: config.owner,
      repo: config.repo,
      issue_number: config.prNumber
    });

    const markedComment = `${marker}\n${comment}`;
    const existingComment = comments.find(c => c.body?.includes(marker));

    if (existingComment) {
      // Update existing comment
      await octokit.issues.updateComment({
        owner: config.owner,
        repo: config.repo,
        comment_id: existingComment.id,
        body: markedComment
      });
    } else {
      // Create new comment
      await octokit.issues.createComment({
        owner: config.owner,
        repo: config.repo,
        issue_number: config.prNumber,
        body: markedComment
      });
    }
  } catch (error) {
    throw new Error(`Failed to upsert GitHub PR comment: ${error}`);
  }
}

/**
 * Create commit annotation (check run annotation)
 */
export async function createGitHubCommitAnnotation(
  config: GitHubConfig & { commitSha: string },
  result: RegressionResult,
  title: string,
  summary: string
): Promise<void> {
  const octokit = new Octokit({
    auth: config.token,
    baseUrl: config.baseUrl
  });

  const conclusion = result.verdict === 'FAIL' ? 'failure' : 
                     result.verdict === 'WARN' ? 'neutral' : 'success';

  try {
    await octokit.checks.create({
      owner: config.owner,
      repo: config.repo,
      name: 'VITALS Regression Check',
      head_sha: config.commitSha,
      status: 'completed',
      conclusion,
      output: {
        title,
        summary,
        annotations: result.verdict !== 'PASS' ? [{
          path: 'deployment',
          start_line: 1,
          end_line: 1,
          annotation_level: result.verdict === 'FAIL' ? 'failure' : 'warning',
          message: `${result.metric}: ${result.change_percent > 0 ? '+' : ''}${result.change_percent.toFixed(1)}% change detected`,
          title: `Regression in ${result.metric}`
        }] : []
      }
    });
  } catch (error) {
    throw new Error(`Failed to create GitHub commit annotation: ${error}`);
  }
}

/**
 * Get GitHub config from environment variables
 */
export function getGitHubConfigFromEnv(): GitHubConfig | null {
  const token = process.env.GITHUB_TOKEN;
  const repository = process.env.GITHUB_REPOSITORY; // Format: owner/repo
  const prNumber = process.env.GITHUB_PR_NUMBER || process.env.PR_NUMBER;

  if (!token || !repository || !prNumber) {
    return null;
  }

  const [owner, repo] = repository.split('/');

  return {
    token,
    owner,
    repo,
    prNumber: parseInt(prNumber, 10),
    baseUrl: process.env.GITHUB_API_URL
  };
}
